import type { TextareaProps } from "@chakra-ui/react";

import type { Dictionary, INode, Lang, Matrix2DFields } from "@carefree0910/core";

import type { IMeta, IPythonFieldsResponse } from "./meta";
import type { IToast } from "./misc";
import type { IPlugin, IPluginInfo } from "./plugins";
import type { IDefinitions } from "./metaFields";

// general

interface IPythonPluginInfo extends IPluginInfo {
  endpoint: string;
  identifier: string;
  updateInterval?: number;
}
export interface IPythonPlugin extends IPlugin {
  pluginInfo: IPythonPluginInfo;
}
interface IPythonCallbacks {
  getExtraRequestData?: () => Dictionary<any>;
}
export interface IUsePythonInfo extends IPythonPluginInfo, IPythonCallbacks {
  isInvisible: boolean;
}
export interface INodeData {
  type?: INode["type"];
  // transform info
  x?: number;
  y?: number;
  w?: number;
  h?: number;
  transform?: Matrix2DFields;
  // text info
  text?: string;
  // image info
  src?: string;
  // meta
  meta?: IMeta;
  // children, in case this is a `Group`
  children?: INodeData[];
}

// plugin

interface IPythonPluginWithSubmitPluginInfo {
  closeOnSubmit?: boolean;
  toastOnSubmit?: boolean;
  toastMessageOnSubmit?: string;
}
interface IPythonPluginWithSubmit {
  id: string;
  buttonText: string;
  pluginInfo: IPythonPluginInfo & IPythonPluginWithSubmitPluginInfo;
}
export interface IPythonFieldsPlugin extends IPythonPlugin {
  pluginInfo: IPythonPluginInfo &
    IPythonPluginWithSubmitPluginInfo & {
      header?: string;
      definitions: IDefinitions;
      numColumns?: number;
    };
}

//// http plugin

interface IPythonHttpPluginCallbacks<R> extends IPythonCallbacks {
  onUseHttpPythonSuccess: (res: IPythonResponse<R>) => Promise<void>;
  onUseHttpPythonError?: (err: any) => Promise<void>;
  beforeRequest?: () => Promise<void>;
  afterResponse?: () => Promise<void>;
}
export interface IPythonHttpPluginWithSubmit<R>
  extends Omit<IPythonPlugin, "id" | "pluginInfo">,
    IPythonHttpPluginCallbacks<R>,
    IPythonPluginWithSubmit {}
export interface IPythonHttpTextAreaPlugin extends IPythonPlugin {
  pluginInfo: IPythonPluginInfo & {
    noLoading?: boolean;
    textAlign?: TextareaProps["textAlign"];
  };
}
export interface IPythonHttpQAPlugin extends IPythonPlugin {
  pluginInfo: IPythonPluginInfo & {
    initialText: string;
  };
}

//// socket plugin

export interface IPythonSocketPluginWithSubmit<R>
  extends Omit<IPythonPlugin, "id" | "pluginInfo">,
    Omit<IPythonSocketCallbacks<R>, "getMessage">,
    IPythonPluginWithSubmit {}

// web

export interface IPythonRequest {
  identifier: string;
  nodeData: INodeData;
  nodeDataList: INodeData[];
  extraData: Dictionary<any>;
  isInternal?: boolean;
}
export interface IPythonResponse<T> {
  success: boolean;
  message: string;
  data: T;
}
export type IPythonOnSocketMessage<R> = (data: IPythonSocketMessage<R>) => Promise<
  | {
      newMessage?: () => Promise<IPythonRequest>;
      /**
       * message generated by `newMessage` will be sent after `newMessageInterval` ms
       *
       * > if `newMessageInterval` is not provided, default `interval` (which is 1000)
       * will be used, which means the message will be sent after 1000ms by default.
       * > if you want to send the new message immediately, you can set it to 0.
       */
      newMessageInterval?: number;
    }
  | undefined
>;
export interface IPythonSocketCallbacks<R> extends IPythonCallbacks {
  getMessage: () => Promise<IPythonRequest>;
  onMessage: IPythonOnSocketMessage<R>;
  onSocketError?: (err: any) => void;
}

// http

export interface IUseHttpPython<R> extends IUsePythonInfo, IPythonHttpPluginCallbacks<R> {
  t: IToast;
  lang: Lang;
  send: boolean;
}

// socket

export type PythonSocketStatus = "pending" | "working" | "finished" | "exception";
interface IPythonSocketIntermediate {
  imageList?: string[]; // intermediate images, if any
  textList?: string[]; // intermediate texts, if any
}
export interface IPythonSocketResponse<R> {
  progress?: number; // progress of current task, should be within [0, 1]
  intermediate?: IPythonSocketIntermediate;
  final?: R;
}
export interface IPythonSocketData<R> {
  status: PythonSocketStatus;
  pending: number;
  message: string;
  data: IPythonSocketResponse<R>;
}
/**
 * for `IPythonSocketMessage`, it should always have `success=true` & `message=""`
 * > this is because socket connection is either alive or dead, and once it's alive,
 * messages will always transfer successfully.
 * > to check whether a request is 'truly' success, we can check the `status` field
 * of the returned `data`. It is one of the `PythonSocketStatus`, and when its value
 * is `exception`, we know something bad is happening, and the message can be extracted
 * from the `message` field of the returned `data`.
 */
export interface IPythonSocketMessage<R> extends IPythonResponse<IPythonSocketData<R>> {}
export interface IUseSocketPython<R>
  extends IUsePythonInfo,
    Omit<IPythonSocketCallbacks<R>, "getMessage"> {
  t: IToast;
  lang: Lang;
  connect: boolean;
}
